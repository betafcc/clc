#!/usr/bin/env bash

clc() {
  local open="${open:-'\e[%bm'}"
  local close="${close:-'\e[0m'}"

  if [ $# -eq 0 ]; then
    clc_parse
  else
    case "${1}" in
      -v|--version) echo 'v2.0.0';;
      -e|--escape)
        shift
        case "${1}" in
          zsh) shift; open='%%{\e[%bm%%}'; close='%%{\e[0m%%}';;
          bash) shift; open='\[\e[%bm\]'; close='\[\e[0m\]';;
          *) shift; open='\001\e[%bm\002'; close='\001\e[0m\002';;
        esac
        clc "$@"
        ;;
      *) printf '%s' "$@" | clc
    esac
  fi
}

clc_parse() (
  while IFS= read -n 1 -d '' char; do
    case "${char}" in
      '>') printf "${close}"; return 0;;
      '<') raw_code=$(clc_parse_directive)
           printf "${open}" "${raw_code}"
           clc_parse "$@" "${raw_code}"
           printf "${open}" "$@";;
      *) printf '%b' "${char}";;
    esac
  done
)

clc_parse_directive() (
  IFS=+ read -r -d ':' -a directives;
  for directive in "${directives[@]}"; do
    directive=(${directive//\#/rgbhex })
    eval clc_code_${directive[@]}
  done | paste -sd ';' -
)

clc_code_black() { echo 30; }
clc_code_red() { echo 31; }
clc_code_green() { echo 32; }
clc_code_yellow() { echo 33; }
clc_code_blue() { echo 34; }
clc_code_magenta() { echo 35; }
clc_code_cyan() { echo 36; }
clc_code_white() { echo 37; }
clc_code_rgb() { echo "38;2;${1};${2};${3}"; }
clc_code_rgbhex() { eval clc_code_rgb $(echo $1 | sed -E -e 's/^(.)(.)(.)$/\1\1\2\2\3\3/;s/.{2}/$((16#&)) /g'); }

clc_code_bg() {
  local fg="$(clc_code_"${@}")"
  echo "4${fg:1}"
}

clc_code_normal() { echo 0; }
clc_code_bold() { echo 1; }
clc_code_dim() { echo 2; }
clc_code_italic() { echo 3; }
clc_code_underline() { echo 4; }
clc_code_blink() { echo 5; }
clc_code_reverse() { echo 7; }
clc_code_invisible() { echo 8; }
clc_code_strike() { echo 9; }

# run `clc` if not being sorced
# https://stackoverflow.com/a/2684300
if [[ "${BASH_SOURCE[0]}" = "${0}" ]]; then
  clc "${@}"
fi
